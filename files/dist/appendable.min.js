(()=>{var w=class t{constructor(e){this.resolver=e}static forUrl(e){return t.forResolver(async({start:r,end:o})=>{let d=await fetch(e,{headers:{Range:`bytes=${r}-${o}`}}),n=Number(d.headers.get("Content-Range").split("/")[1]);return{data:await d.arrayBuffer(),totalLength:n}})}static forResolver(e){return new t(async(r,o)=>(await e({start:r,end:o})).data)}async get(e,r){let o=await this.resolver(e,r);return new TextDecoder().decode(o)}};function N(t){try{return JSON.parse(t)}catch(e){let r=e.message.match(/position\s+(\d+)/);r&&(t=t.slice(0,r[1]))}return JSON.parse(t)}function T(t){if(t===null)return 1;if(typeof t=="boolean")return 2;if(typeof t=="number"||typeof t=="bigint")return 3;if(typeof t=="string")return 4;throw new Error("unknown type")}function R(t,e){let r=T(t),o=T(e);if(r!==o)return r-o;switch(r){case 1:return 0;case 2:return t?1:-1;case 3:return t-e;case 4:return t.localeCompare(e);default:throw new Error("unknown type")}}var b=class t{constructor(e,r){this.dataFile=e;this.indexFile=r}static forDataFileAndIndexFile(e,r){return new t(e,r)}async fields(){return await this.indexFile.indexHeaders()}async*query(e){if(new Set((e.where??[]).map(i=>i.key)).size>1)throw new Error("composite indexes not supported... yet");let r=await this.indexFile.indexHeaders(),o=await Promise.all((e.where??[]).map(async({key:i,value:s,operation:a})=>{let u=r.find(f=>f.fieldName===i);if(!u)throw new Error("field not found");let h=0,x=Number(u.indexRecordCount);if(a===">"||a===">="||a==="=="){let f=0,l=Number(u.indexRecordCount);for(;f+1<l;){let c=Math.floor((f+l)/2),g=await this.indexFile.indexRecord(i,c),y=await this.dataFile.get(g.fieldStartByteOffset,g.fieldStartByteOffset+g.fieldLength),B=N(y);console.log(c,B),R(s,B)<0?l=c:R(s,B)>0||a===">"?f=c+1:l=c}h=l}if(a==="<"||a==="<="||a==="=="){let f=0,l=Number(u.indexRecordCount);for(;f+1<l;){let c=Math.floor((f+l)/2),g=await this.indexFile.indexRecord(i,c),y=N(await this.dataFile.get(g.fieldStartByteOffset,g.fieldStartByteOffset+g.fieldLength));R(s,y)<0?l=c:R(s,y)>0?f=c+1:a==="<"?l=c:f=c+1}x=l}return[i,[h,x]]})),d=new Map;for(let[i,s]of o){let a=d.get(i);a?d.set(i,[Math.max(a[0],s[0]),Math.min(a[1],s[1])]):d.set(i,s)}let n=[...d.entries()].sort((i,s)=>i[1][1]-i[1][0]-(s[1][1]-s[1][0])),m=(e.orderBy??[]).map(i=>i.key);for(let i of m){let s=n.findIndex(a=>a[0]===i);s>=0&&n.unshift(...n.splice(s,1))}for(let[i,[s,a]]of n){console.log(e.orderBy);let u=e.orderBy?.find(f=>f.key===i);console.log(u);let h=u?.direction==="DESC";console.log(i,s,a,h);let x=a-s;for(let f=0;f<x;f++){let l=h?a-f-1:s+f,c=await this.indexFile.indexRecord(i,l),g=await this.indexFile.dataRecord(c.dataNumber);yield N(await this.dataFile.get(g.startByteOffset,g.endByteOffset))}}}};var F=class extends Error{constructor(){super("length integrity error")}};var p=class t{static async forUrl(e){return await t.forResolver(async({start:r,end:o,expectedLength:d})=>{let n=await fetch(e,{headers:{Range:`bytes=${r}-${o}`}}),m=Number(n.headers.get("Content-Range").split("/")[1]);if(d&&m!==d)throw new F;return{data:await n.arrayBuffer(),totalLength:m}})}static async forResolver(e){let r=await e({start:0,end:0});switch(new DataView(r.data).getUint8(0)){case 1:return new v(async(d,n)=>(await e({start:d,end:n,expectedLength:r.totalLength})).data);default:throw new Error("invalid version")}}};function E(t){let e=t>>11,r=t&2047;return(1<<e)*r+(1<<e+11)-2048}var v=class t{constructor(e){this.resolver=e}_indexFileHeader;_indexHeaders;static INDEX_RECORD_SIZE=18;async indexFileHeader(){if(this._indexFileHeader)return this._indexFileHeader;let e=new DataView(await this.resolver(1,16));return this._indexFileHeader={indexLength:Number(e.getBigUint64(0)),dataCount:Number(e.getBigUint64(8))},this._indexFileHeader}async indexHeaders(){if(this._indexHeaders)return this._indexHeaders;let e=await this.indexFileHeader(),r=await this.resolver(17,e.indexLength+16),o=new DataView(r),d=[],n=0;for(;n<e.indexLength;){let m=o.getUint32(n);n+=4;let i=new TextDecoder("utf-8").decode(r.slice(n,n+m));n+=m;let s=o.getBigUint64(n);n+=8;let a=o.getBigUint64(n);n+=8,d.push({fieldName:i,fieldType:s,indexRecordCount:a})}if(n!==e.indexLength)throw new Error(`Inaccurate header read, offset = ${n} but indexFileHeader.indexLength = ${e.indexLength}. This could indicate that the index file is corrupt.`);return this._indexHeaders=d,d}async indexRecord(e,r){if(r<0)throw new Error("offset out of range");let o=await this.indexHeaders(),d=o.findIndex(c=>c.fieldName===e);if(d===-1)throw new Error("field not found");let n=o[d];if(r>=Number(n.indexRecordCount))throw new Error("offset out of range");let i=17+(await this.indexFileHeader()).indexLength,s=o.slice(0,d).reduce((c,g)=>c+Number(g.indexRecordCount)*t.INDEX_RECORD_SIZE,0),a=i+s+r*t.INDEX_RECORD_SIZE,u=await this.resolver(a,a+t.INDEX_RECORD_SIZE),h=new DataView(u),x=h.getBigUint64(0),f=h.getBigUint64(8),l=E(h.getUint16(16));return{dataNumber:Number(x),fieldStartByteOffset:Number(f),fieldLength:l}}async dataRecord(e){if(e<0)throw new Error("offset out of range");let r=await this.indexFileHeader();if(e>=r.dataCount)throw new Error("offset out of range");let d=(await this.indexHeaders()).reduce((u,h)=>u+Number(h.indexRecordCount)*t.INDEX_RECORD_SIZE,0),n=17+r.indexLength+d;if(e===0){let u=await this.resolver(n+e*8,n+e*8+8),x=new DataView(u).getBigUint64(0);return{startByteOffset:0,endByteOffset:Number(x)}}let m=await this.resolver(n+(e-1)*8,n+e*8+8),i=new DataView(m),s=i.getBigUint64(0),a=i.getBigUint64(8);return{startByteOffset:Number(s),endByteOffset:Number(a)}}};async function O(t,e){return b.forDataFileAndIndexFile(typeof t=="string"?w.forUrl(t):w.forResolver(t),typeof e=="string"?await p.forUrl(e):await p.forResolver(e))}globalThis.Appendable={init:O};})();
//# sourceMappingURL=appendable.min.js.map
